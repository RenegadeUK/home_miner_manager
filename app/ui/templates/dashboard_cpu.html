{% extends "dashboard_base.html" %}

{% block dashboard_tiles %}
<!-- CPU-Specific Stats Grid -->
<div class="stats-grid compact-grid">
    <div class="stat-card" onclick="window.location.href='/miners'" style="cursor: pointer;">
        <div class="stat-label">Workers Online</div>
        <div class="stat-value" id="workers-online">0</div>
        <div class="stat-subtext">
            <div id="total-hashrate">0 KH/s</div>
        </div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Pool Hashrate</div>
        <div class="stat-value" id="pool-hashrate-value">Unavailable</div>
        <div class="stat-subtext">
            <div id="pool-efficiency">Efficiency: Unavailable</div>
        </div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Cost (24h)</div>
        <div class="stat-value" id="total-cost-24h">£0.00</div>
        <div class="stat-subtext">
            <div id="avg-price-per-kwh">Avg: Unavailable</div>
        </div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Earnings (24h) <span class="coin-pill xmr">XMR</span></div>
        <div class="stat-value" id="earnings-24h">0.000000 XMR</div>
        <div class="stat-subtext">
            <div id="earnings-24h-gbp">£0.00</div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
{{ super() }}
<script>
// CPU Dashboard - Load data and update tiles
async function loadDashboard() {
    try {
        // Reset pool hashrate counter
        totalPoolHashrateRaw = 0;
        
        // Get dashboard type from template
        const dashboardType = '{{ dashboard_type }}';
        
        // Single optimized API call that returns everything
        const response = await fetch(`/api/dashboard/all?dashboard_type=${dashboardType}`, {
            cache: 'no-cache',
            headers: {
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'Pragma': 'no-cache'
            }
        });
        const data = await response.json();
        
        // Update stats
        const stats = data.stats;
        document.getElementById('workers-online').textContent = stats.online_miners || 0;
        
        // Store current energy price globally for solopool stats calculation
        window.currentEnergyPrice = stats.current_energy_price_pence;
        
        // Store miner hashrate globally (convert to KH/s for CPU miners)
        window.currentMinerHashrate = stats.total_hashrate_ghs || 0;
        
        // Update total hashrate (CPU miners report in KH/s, but API returns GH/s)
        // For CPU miners, the hashrate is actually in KH/s stored as GH/s value
        const totalHashrate = stats.total_hashrate_ghs || 0;
        document.getElementById('total-hashrate').textContent = totalHashrate > 0 ? `${totalHashrate.toFixed(2)} KH/s` : '0 KH/s';
        
        // Update cost (24h)
        document.getElementById('total-cost-24h').textContent = 
            stats.total_cost_24h_pounds !== undefined ? '£' + stats.total_cost_24h_pounds.toFixed(2) : '£0.00';
        
        // Update average price per kWh
        const avgPriceEl = document.getElementById('avg-price-per-kwh');
        if (stats.avg_price_per_kwh_pence && stats.avg_price_per_kwh_pence > 0) {
            avgPriceEl.textContent = `Avg: ${stats.avg_price_per_kwh_pence.toFixed(1)}p / kWh`;
        } else {
            avgPriceEl.textContent = 'Avg: Unavailable';
        }
        
        // Update earnings (24h) - will be populated after SupportXMR stats load
        const earnings24h = stats.earnings_24h_pounds || 0;
        
        // Fetch XMR price to display earnings in XMR
        try {
            const priceResponse = await fetch('/api/settings/crypto-prices');
            if (priceResponse.ok) {
                const priceData = await priceResponse.json();
                if (priceData.success && priceData.monero > 0) {
                    const xmrPriceGBP = priceData.monero;
                    const earningsXMR = earnings24h / xmrPriceGBP;
                    document.getElementById('earnings-24h').textContent = earningsXMR.toFixed(6) + ' XMR';
                    document.getElementById('earnings-24h-gbp').textContent = '£' + earnings24h.toFixed(2);
                } else {
                    document.getElementById('earnings-24h').textContent = '0.000000 XMR';
                    document.getElementById('earnings-24h-gbp').textContent = '£' + earnings24h.toFixed(2);
                }
            }
        } catch (e) {
            console.error('Failed to fetch XMR price:', e);
        }

        // Load CPU pool integration stats (RandomX pools only)
        await loadSupportXMRStats();
        await loadSolopoolStats('cpu');  // XMR only
        
        // Update pool hashrate tile after SupportXMR loads
        updatePoolHashrateTile();
    } catch (error) {
        console.error('Failed to load CPU dashboard:', error);
    }
}

// Update pool hashrate tile with SupportXMR data
async function updatePoolHashrateTile() {
    try {
        const response = await fetch('/api/settings/supportxmr/stats');
        const data = await response.json();
        
        if (data.enabled && data.wallets && data.wallets.length > 0) {
            // Get total pool hashrate from all wallets
            let totalPoolHashrate = 0;
            let totalWorkers = 0;
            
            for (const wallet of data.wallets) {
                totalWorkers += wallet.worker_count || 0;
                
                // Parse hashrate from formatted string (e.g., "1.23 KH/s")
                if (wallet.hashrate) {
                    const match = wallet.hashrate.match(/([\d.]+)\s*([KMG]?H\/s)/i);
                    if (match) {
                        const value = parseFloat(match[1]);
                        const unit = match[2].toUpperCase();
                        
                        // Convert to KH/s
                        if (unit === 'H/S') {
                            totalPoolHashrate += value / 1000;
                        } else if (unit === 'KH/S') {
                            totalPoolHashrate += value;
                        } else if (unit === 'MH/S') {
                            totalPoolHashrate += value * 1000;
                        } else if (unit === 'GH/S') {
                            totalPoolHashrate += value * 1000000;
                        }
                    }
                }
            }
            
            // Update pool hashrate display
            const poolHashrateEl = document.getElementById('pool-hashrate-value');
            if (totalPoolHashrate > 0) {
                poolHashrateEl.textContent = totalPoolHashrate.toFixed(2) + ' KH/s';
            } else {
                poolHashrateEl.textContent = 'Unavailable';
            }
            
            // Calculate efficiency (pool hashrate vs miner hashrate)
            const minerHashrate = window.currentMinerHashrate || 0;
            const poolEfficiencyEl = document.getElementById('pool-efficiency');
            
            if (minerHashrate > 0 && totalPoolHashrate > 0) {
                const efficiency = (totalPoolHashrate / minerHashrate) * 100;
                
                // Apply color based on thresholds
                let color = '';
                if (efficiency >= 95) {
                    color = '#28a745'; // green
                } else if (efficiency >= 85) {
                    color = '#ffc107'; // amber
                } else {
                    color = '#dc3545'; // red
                }
                
                poolEfficiencyEl.textContent = `${efficiency.toFixed(0)}% of expected`;
                poolEfficiencyEl.style.color = color;
            } else {
                poolEfficiencyEl.textContent = 'Efficiency: Unavailable';
                poolEfficiencyEl.style.color = '';
            }
        } else {
            document.getElementById('pool-hashrate-value').textContent = 'Unavailable';
            document.getElementById('pool-efficiency').textContent = 'Efficiency: Unavailable';
        }
    } catch (error) {
        console.error('Failed to update pool hashrate tile:', error);
    }
}
</script>
{% endblock %}
